<div class="container">

<table style="width: 100%;"><tr>
<td>make_sampling_table</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Generates a word rank-based probabilistic sampling table.</h2>

<h3>Description</h3>

<p>Generates a word rank-based probabilistic sampling table.
</p>


<h3>Usage</h3>

<pre><code class="language-R">make_sampling_table(size, sampling_factor = 1e-05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>size</code></td>
<td>
<p>Int, number of possible words to sample.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sampling_factor</code></td>
<td>
<p>The sampling factor in the word2vec formula.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Used for generating the <code>sampling_table</code> argument for <code>skipgrams()</code>.
<code>sampling_table[[i]]</code> is the probability of sampling the word i-th most common
word in a dataset (more common words should be sampled less frequently, for balance).
</p>
<p>The sampling probabilities are generated according to the sampling distribution used in word2vec:
</p>
<p><code>p(word) = min(1, sqrt(word_frequency / sampling_factor) / (word_frequency / sampling_factor))</code>
</p>
<p>We assume that the word frequencies follow Zipf's law (s=1) to derive a
numerical approximation of frequency(rank):
</p>
<p><code>frequency(rank) ~ 1/(rank * (log(rank) + gamma) + 1/2 - 1/(12*rank))</code>
</p>
<p>where <code>gamma</code> is the Euler-Mascheroni constant.
</p>


<h3>Value</h3>

<p>An array of length <code>size</code> where the ith entry is the
probability that a word of rank i should be sampled.
</p>


<h3>Note</h3>

<p>The word2vec formula is: p(word) = min(1,
sqrt(word.frequency/sampling_factor) / (word.frequency/sampling_factor))
</p>


<h3>See Also</h3>

<p>Other text preprocessing: 
<code>pad_sequences()</code>,
<code>skipgrams()</code>,
<code>text_hashing_trick()</code>,
<code>text_one_hot()</code>,
<code>text_to_word_sequence()</code>
</p>


</div>