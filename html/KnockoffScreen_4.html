<div class="container">

<table style="width: 100%;"><tr>
<td>KS.summary</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Summarize KnockoffScreen results
</h2>

<h3>Description</h3>

<p>Summarize results generated by function KS.VCF.chr(). Calculate q-values for each window/variant.
</p>


<h3>Usage</h3>

<pre><code class="language-R">KS.summary(result.window,result.single,M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>result.window</code></td>
<td>

<p>A result matrix generated by KS.VCF.chr() for all windows. Each row present a tested window. If the genome is partitioned into smaller regions and parellel computing is applied (e.g. each chromosome can be partitioned into 50 contiguous regions), the result matrices should be combined and then processed by KS.summary() jointly for genome-wide FDR control.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>result.single</code></td>
<td>

<p>A result matrix generated by KS.VCF.chr() for individual variants with minor allele frequency above the specified threshold. Each row present a tested variant. If the genome is partitioned into smaller segments and parellel computing is applied (e.g. each chromosome can be partitioned into 50 contiguous segments), the result matrices should be combined and then processed by KS.summary() jointly for genome-wide FDR control.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>M</code></td>
<td>

<p>Number of knockoffs per variant. Should be same as M used in KS.VCF.chr().
</p>
</td>
</tr>
</table>
<h3>Value</h3>

<table><tr style="vertical-align: top;">
<td><code>result.summary</code></td>
<td>

<p>A matrix summarizing the KnockoffScreen results.
</p>
</td>
</tr></table>
<h3>Examples</h3>

<pre><code class="language-R">
library(KnockoffScreen)

# load example vcf file from package "seqminer"
vcf.filename = system.file("vcf/1000g.phase1.20110521.CFH.var.anno.vcf.gz", package = "seqminer")

## this is how the actual genotype matrix from package "seqminer" looks like
example.G &lt;- t(readVCFToMatrixByRange(vcf.filename, "1:196621007-196716634",annoType='')[[1]])

# simulated outcomes, covariates and inidividual id.
Y&lt;-as.matrix(rnorm(nrow(example.G),0,1))
X&lt;-as.matrix(rnorm(nrow(example.G),0,1))
id&lt;-rownames(example.G)

# fit null model
result.prelim&lt;-KS.prelim(Y,X=X,id=id,out_type="C")

# Define the window.bed file
chr&lt;-1
pos.min&lt;-196621007;pos.max&lt;-196716634
window.size=c(2000)

window.bed&lt;-c();
for(size in window.size){
  pos.tag&lt;-seq(pos.min,pos.max,by=size*1/2)
  window.bed&lt;-rbind(window.bed,cbind(chr,pos.tag,pos.tag+size))
}
window.bed&lt;-window.bed[order(as.numeric(window.bed[,2])),]

# scan the vcf file
midout.dir&lt;-NULL # or '/YourProjectDir/MidResults/'
temp.dir&lt;-NULL # or '/YourProjectDir/Temp_out/' #this is a folder to save temporary results
jobtitle&lt;-'YourProjectTitle'

# we set thres.single=0.1,thres.ultrarare=0 for a proof of concept.
# note that the default for real data analysis is thres.single=0.01, thres.ultrarare=25
fit &lt;- KS.chr(result.prelim,vcf.filename,window.bed,M=5,thres.single=0.1,thres.ultrarare=0,
midout.dir=midout.dir,temp.dir=temp.dir,jobtitle=jobtitle)

# summarize the results
result.summary&lt;-KS.summary(fit$result.window,fit$result.single,M=5)

</code></pre>


</div>