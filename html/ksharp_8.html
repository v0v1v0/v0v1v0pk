<div class="container">

<table style="width: 100%;"><tr>
<td>silinfo</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Compute info on silhouette widths</h2>

<h3>Description</h3>

<p>This function provides information on how well each data point
belongs to its cluster. For each query point, the function considers
the average distance to other members of the same cluster and the
average distance to members of another, nearest, cluster. The widths
are defined as the
</p>


<h3>Usage</h3>

<pre><code class="language-R">silinfo(cluster, dist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>cluster</code></td>
<td>
<p>vector with assignments of data elements to clusters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dist</code></td>
<td>
<p>distance object or matrix</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The function signature is very similar to cluster::silhouette but
the implementation has important differences. This implementation
requires both the dist object and and cluster vector must have names.
This prevents accidental assignment of silhouette widths to the wrong
elements.
</p>


<h3>Value</h3>

<p>list, analogous to object within output from cluster::pam.
In particular, the list has a component widths. The widths object is
matrix with one row per data item, with column sil_width holding the
silhouette width.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# construct a manual clustering of the iris dataset
iris.data = iris[, 1:4]
rownames(iris.data) = paste0("iris_", seq_len(nrow(iris.data)))
iris.dist = dist(iris.data)
iris.clusters = setNames(as.integer(iris$Species), rownames(iris.data))

# compute sharpness values based on silhouette widths
silinfo(iris.clusters, iris.dist)

</code></pre>


</div>