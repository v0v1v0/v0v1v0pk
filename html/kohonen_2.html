<div class="container">

<table style="width: 100%;"><tr>
<td>plot.kohonen</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Plot kohonen object</h2>

<h3>Description</h3>

<p>Plot objects of class <code>kohonen</code>. Several types
of plots are supported.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'kohonen'
plot(x, type = c("codes", "changes", "counts",
                       "dist.neighbours", "mapping", "property", "quality"),
                       whatmap = NULL, classif = NULL, labels = NULL,
                       pchs = NULL, main = NULL, palette.name = NULL,
                       ncolors, bgcol = NULL, zlim = NULL,
                       heatkey = TRUE, property, codeRendering = NULL,
                       keepMargins = FALSE, heatkeywidth = .2,
                       shape = c("round", "straight"), border = "black",
                       na.color = "gray", ...)
## S3 method for class 'kohonen'
identify(x, ...)
add.cluster.boundaries(x, clustering, lwd = 5, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>kohonen object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>type of plot. (Wow!)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>whatmap</code></td>
<td>
<p>For a "codes" plot: what maps
to show; for the "dist.neighbours" plot: what maps to take into
account when calculating distances to neighbouring units.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>classif</code></td>
<td>
<p>classification object, as returned by
<code>predict.kohonen</code>, or vector of unit numbers.
Only needed if <code>type</code> equals "mapping" and
"counts".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>labels</code></td>
<td>
<p>labels to plot when <code>type</code> equals
"mapping".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pchs</code></td>
<td>
<p>symbols to plot when <code>type</code> equals
"mapping".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>main</code></td>
<td>
<p>title of the plot.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>palette.name</code></td>
<td>
<p>colors to use as unit background for "codes",
"counts", "prediction", "property", and "quality" plotting types.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncolors</code></td>
<td>
<p>number of colors to use for the unit
backgrounds. Default is 20 for continuous data, and the number of
distinct values (if less than 20) for categorical data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bgcol</code></td>
<td>
<p>optional argument to colour the unit backgrounds for the
"mapping" and "codes" plotting type. Defaults to "gray" and
"transparent" in both types, respectively.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>zlim</code></td>
<td>
<p>optional range for color coding of unit backgrounds.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>heatkey</code></td>
<td>
<p>whether or not to generate a heatkey at the left side
of the plot in the "property" and "counts" plotting types.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>property</code></td>
<td>
<p>values to use with the "property" plotting
type.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>codeRendering</code></td>
<td>
<p>How to show the codes. Possible choices:
"segments", "stars" and "lines".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keepMargins</code></td>
<td>
<p>if <code>FALSE</code> (the default), restore the original
graphical parameters after plotting the kohonen map. If <code>TRUE</code>,
one retains the map coordinate system so that one can add symbols to
the plot, or map unit numbers using the <code>identify</code> function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>heatkeywidth</code></td>
<td>
<p>width of the colour key; the default of 0.2 should
work in most cases but in some cases, e.g. when plotting multiple
figures, it may need to be adjusted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>shape</code></td>
<td>
<p>kind shape to be drawn: "round" (circle) or "straight".
Choosing "straight" produces a map of squares when the grid is
"rectangular", and produces a map of hexagons when the grid is
"hexagonal".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>border</code></td>
<td>
<p>color of the shape's border.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.color</code></td>
<td>
<p>background color matching NA - default "gray".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lwd, ...</code></td>
<td>
<p>other graphical parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clustering</code></td>
<td>
<p>cluster labels of the map units.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Several different types of plots are supported:
</p>

<dl>
<dt>"changes"</dt>
<dd>
<p>shows the mean distance to the closest codebook vector
during training.</p>
</dd>
<dt>"codes"</dt>
<dd>
<p>shows the codebook vectors.</p>
</dd>
<dt>"counts"</dt>
<dd>
<p>shows the number of objects mapped to the
individual units. Empty units are depicted in gray.</p>
</dd>
<dt>"dist.neighbours"</dt>
<dd>
<p>shows the sum of the distances to all
immediate neighbours. This kind of visualisation is also known as
a U-matrix plot. Units near a class boundary can be expected to
have higher average distances to their neighbours. Only available
for the "som" and "supersom" maps, for the moment.</p>
</dd>
<dt>"mapping"</dt>
<dd>
<p>shows where objects are mapped. It
needs the "classif" argument, and a "labels" or "pchs"
argument.</p>
</dd>
<dt>"property"</dt>
<dd>
<p>properties of each unit can be calculated and
shown in colour code. It can be used to visualise the similarity
of one particular object to all units in the map, to show the mean
similarity of all units and the objects mapped to them,
etcetera. The parameter <code>property</code> contains the numerical
values. See examples below.</p>
</dd>
<dt>"quality"</dt>
<dd>
<p>shows the mean distance of objects mapped to a
unit to the codebook vector of that unit. The smaller the
distances, the better the objects are represented by the codebook
vectors. It is possible to visualize this for the complete set of
layers used in training, or for individual layers only (using the
<code>whatmap</code> argument).</p>
</dd>
</dl>
<p>Function <code>identify.kohonen</code> shows the number of a unit that is
clicked on with the mouse. The tolerance is calculated from the ratio
of the plotting region and the user coordinates, so clicking at any
place within a unit should work.
</p>
<p>Function <code>add.cluster.boundaries</code> will add to an existing plot of
a map thick lines, visualizing which units would be clustered
together. In toroidal maps, boundaries at the edges will only be shown
on the top and right sides to avoid double boundaries.
</p>


<h3>Value</h3>

<p>Several types of plots return useful values (invisibly): the
<code>"counts"</code>, <code>"dist.neighbours"</code>, and <code>"quality"</code> return
vectors corresponding to the information visualized in the plot (unit
background colours and heatkey).
</p>


<h3>Author(s)</h3>

<p>Ron Wehrens</p>


<h3>See Also</h3>

<p><code>som</code>, <code>supersom</code>, <code>xyf</code>,
<code>predict.kohonen</code></p>


<h3>Examples</h3>

<pre><code class="language-R">data(wines)
set.seed(7)

kohmap &lt;- xyf(scale(wines), vintages,
              grid = somgrid(5, 5, "hexagonal"), rlen=100)
plot(kohmap, type="changes")
counts &lt;- plot(kohmap, type="counts", shape = "straight")

## show both sets of codebook vectors in the map
par(mfrow = c(1,2))
plot(kohmap, type="codes", main = c("Codes X", "Codes Y"))

par(mfrow = c(1,1))
similarities &lt;- plot(kohmap, type="quality", palette.name = terrain.colors)
plot(kohmap, type="mapping",
     labels = as.integer(vintages), col = as.integer(vintages),
     main = "mapping plot")

## add background colors to units according to their predicted class labels
xyfpredictions &lt;- classmat2classvec(getCodes(kohmap, 2))
bgcols &lt;- c("gray", "pink", "lightgreen")
plot(kohmap, type="mapping", col = as.integer(vintages),
     pchs = as.integer(vintages), bgcol = bgcols[as.integer(xyfpredictions)],
     main = "another mapping plot", shape = "straight", border = NA)

## Show 'component planes'
set.seed(7)
sommap &lt;- som(scale(wines), grid = somgrid(6, 4, "hexagonal"))
plot(sommap, type = "property", property = getCodes(sommap, 1)[,1],
     main = colnames(getCodes(sommap, 1))[1])

## Show the U matrix
Umat &lt;- plot(sommap, type="dist.neighbours", main = "SOM neighbour distances")
## use hierarchical clustering to cluster the codebook vectors
som.hc &lt;- cutree(hclust(object.distances(sommap, "codes")), 5)
add.cluster.boundaries(sommap, som.hc)

## and the same for rectangular maps
set.seed(7)
sommap &lt;- som(scale(wines),grid = somgrid(6, 4, "rectangular"))
plot(sommap, type="dist.neighbours", main = "SOM neighbour distances")
## use hierarchical clustering to cluster the codebook vectors
som.hc &lt;- cutree(hclust(object.distances(sommap, "codes")), 5)
add.cluster.boundaries(sommap, som.hc)
</code></pre>


</div>