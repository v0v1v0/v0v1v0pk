<div class="container">

<table style="width: 100%;"><tr>
<td>knn.forecast.boot.intervals</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>KNN Forecast Bootstrap Prediction Intervals</h2>

<h3>Description</h3>

<p>A function for forecasting using KNN regression with prediction intervals. The approach is based on the description of
"Prediction intervals from bootstrapped residuals" from chapter 5.5 of Hyndman R, Athanasopoulos G (2021) <a href="https://otexts.com/fpp3/prediction-intervals.html#prediction-intervals-from-bootstrapped-residuals">https://otexts.com/fpp3/prediction-intervals.html#prediction-intervals-from-bootstrapped-residuals</a>,
modified as needed for use with KNN regression. The algorithm starts by calculating a pool of forecast errors to later
sample from. If there are <code>n</code> points prior to the first observation indicated in <code>f.index.in</code> then there will be <code>n - k.in</code> errors generated by one-step ahead forecasts
starting with the point of the response series at the index <code>k.in + 1</code>. The first <code>k.in</code> points cannot be estimated because
a minimum of <code>k.in</code> eligible neighbors would be needed. The optional <code>burn.in</code> argument can be used to increase the number
of points from the start of the series that need to be available as neighbors before calculating errors for the pool. Next, <code>B</code>
possible paths the series could take are simulated using the pool of errors. Each path is simulated by calling <code>knn.forecast()</code>, estimating the first point in <code>f.index.in</code>, adding a sampled forecast error, then adding
this value to the end of the series. This process is then repeated for the next point in <code>f.index.in</code> until all have been estimated. The final output
interval estimates are calculated for each point in <code>f.index.in</code> by taking the appropriate percentiles of the corresponding simulations of that point.
The mean and medians are also calculated from these simulations. One important implication of this behavior is that the mean forecast output from this function can
differ from the point forecast produced by <code>knn.forecast()</code> alone.
</p>


<h3>Usage</h3>

<pre><code class="language-R">knn.forecast.boot.intervals(
  Sim.Mat.in,
  f.index.in,
  k.in,
  y.in,
  burn.in = NULL,
  B = 200,
  return.simulations = FALSE,
  level = 0.95
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Sim.Mat.in</code></td>
<td>
<p>numeric and symmetric matrix of similarities (recommend use of <code>S_w</code>, see <code>SwMatrixCalc()</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>f.index.in</code></td>
<td>
<p>numeric vector indicating the indices of <code>Sim.Mat.in</code> and <code>y.in</code> which correspond to the time order of the points to be forecast.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k.in</code></td>
<td>
<p>integer value indicating the the number of nearest neighbors to be considered in forecasting, must be <code>&gt;= 1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y.in</code></td>
<td>
<p>numeric vector of the response series to be forecast.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>burn.in</code></td>
<td>
<p>integer value which indicates how many points at the start of the series to set aside as eligible neighbors before calculating forecast errors to be re-sampled.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>B</code></td>
<td>
<p>integer value representing the number of bootstrap replications, this will be the number of forecasts simulated and used to calculate outputs, must be <code>&gt;= 1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>return.simulations</code></td>
<td>
<p>logical value indicating whether to return all simulated forecasts.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>level</code></td>
<td>
<p>numeric value over the range (0,1) indicating the confidence level for the prediction intervals.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>list of the following components:
</p>

<dl>
<dt>lb</dt>
<dd>
<p>numeric vector of the same length as <code>f.index.in</code>, with the estimated lower bound of the prediction interval.</p>
</dd>
<dt>ub</dt>
<dd>
<p>numeric vector of the same length as <code>f.index.in</code>, with the estimated upper bound of the prediction interval.</p>
</dd>
<dt>mean</dt>
<dd>
<p>numeric vector of the same length as <code>f.index.in</code>, with the mean of the <code>B</code> simulated paths for each forecasted point.</p>
</dd>
<dt>median</dt>
<dd>
<p>numeric vector of the same length as <code>f.index.in</code>, with the median of the <code>B</code> simulated paths for each forecasted point.</p>
</dd>
<dt>simulated.paths</dt>
<dd>
<p>numeric matrix where each of the <code>B</code> rows contains a simulated path for the points in <code>f.index.in</code>, only returned if <code>return.simulations = TRUE</code>.</p>
</dd>
</dl>
<h3>See Also</h3>


<ul>
<li> <p><code>knn.forecast()</code> for the function called to perform knn regression.
</p>
</li>
<li> <p><code>SwMatrixCalc()</code> for the function to calculate a matrix with the recommended similarity measure.
</p>
</li>
<li>
<p> Hyndman R, Athanasopoulos G (2021),"Forecasting: Principles and Practice, 3rd ed", Chapter 5.5, <a href="https://otexts.com/fpp3/prediction-intervals.html#prediction-intervals-from-bootstrapped-residuals">https://otexts.com/fpp3/prediction-intervals.html#prediction-intervals-from-bootstrapped-residuals</a>.
For background on the algorithm this function is based on.
</p>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R">data("simulation_master_list")
series.index &lt;- 15
ex.series &lt;- simulation_master_list[[series.index]]$series.lin.coef.chng.x

# Weights pre tuned by random search. In alpha, beta, gamma order
pre.tuned.wts &lt;- c(0.2148058, 0.2899638, 0.4952303)
pre.tuned.k &lt;- 5

df &lt;- data.frame(ex.series)
# Generate vector of time orders
df$t &lt;- c(1:nrow(df))

# Generate vector of periods
nperiods &lt;- simulation_master_list[[series.index]]$seasonal.periods
df$p &lt;- rep(1:nperiods, length.out = nrow(df))

# Pull corresponding exogenous predictor(s)
X &lt;- as.matrix(simulation_master_list[[series.index]]$x.chng)


# Calculate the weighted similarity matrix using Sw
Sw.ex &lt;- SwMatrixCalc(
  t.in = df$t,
  p.in = df$p, nPeriods.in = nperiods,
  X.in = X,
  weights = pre.tuned.wts
)

n &lt;- length(ex.series)
# Index we want to forecast
f.index &lt;- c((n - 5 + 1):length(ex.series))

interval.forecast &lt;- knn.forecast.boot.intervals(
  Sim.Mat.in = Sw.ex,
  f.index.in = f.index,
  y.in = ex.series,
  k.in = pre.tuned.k
)
</code></pre>


</div>