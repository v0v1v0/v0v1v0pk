<div class="container">

<table style="width: 100%;"><tr>
<td>adaptive_fnhat</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Specialized “Workhorse” Function for Kernel Adaptive Density Estimators</h2>

<h3>Description</h3>

<p>Common specialized computational “workhorse” function to compute the kernel
adaptive density estimators both in eq. (1.6) of Srihera &amp; Stute (2011) and
in eq. (4) of Eichner &amp; Stute (2013) (together with several related
quantities) with a <code class="reqn">\sigma</code> that minimizes the estimated MSE using an
estimated <code class="reqn">\theta</code>. This function is “specialized” in that it expects
some pre-computed quantities (in addition to the point(s) at which the
density is to be estimated, the data, etc.). In particular, the estimator of
<code class="reqn">\theta</code> (which is typically the arithmetic mean of the data) is
expected to be already “contained” in those pre-computed quantities, which
increases the computational efficiency.
</p>


<h3>Usage</h3>

<pre><code class="language-R">adaptive_fnhat(x, data, K, h, sigma, Ai, Bj, fnx, ticker = FALSE,
  plot = FALSE, parlist = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Numeric vector <code class="reqn">(x_1, \ldots, x_k)</code> of location(s) at which the
density estimate is to be computed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>Numeric vector <code class="reqn">(X_1, \ldots, X_n)</code> of the data from which
the estimate is to be computed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>K</code></td>
<td>
<p>Kernel function with vectorized in- &amp; output.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>h</code></td>
<td>
<p>Numeric scalar, where (usually) <code class="reqn">h = n^{-1/5}</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma</code></td>
<td>
<p>Numeric vector <code class="reqn">(\sigma_1, \ldots, \sigma_s)</code> with
<code class="reqn">s \ge 1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Ai</code></td>
<td>
<p>Numeric matrix expecting in its i-th row <code class="reqn">(x_i - X_1, \ldots,
x_i - X_n)/h</code>, where (usually) <code class="reqn">x_1, \ldots, x_k</code> with
<code class="reqn">k =</code> <code>length(x)</code> are the points at which the density is
to be estimated for the data <code class="reqn">X_1, \ldots, X_n</code> with
<code class="reqn">h = n^{-1/5}</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Bj</code></td>
<td>
<p>Numeric vector expecting <code class="reqn">(-J(1/n), \ldots, -J(n/n))</code> in
case of the rank transformation method, but <code class="reqn">(\hat \theta -
X_1, \ldots, \hat \theta - X_n)</code> in case of the non-robust
Srihera-Stute-method.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fnx</code></td>
<td>
<p>Numeric vector expecting <code class="reqn">(f_n(x_1), \ldots, f_n(x_k))</code> with
<code class="reqn">f_n(x_i)</code> the Parzen-Rosenblatt estimator at <code class="reqn">x_i</code>, i.e.,
<code class="reqn">f_n(x_i) =</code> <code>mean(K(Ai[i,]))/h</code> where here typically
<code>h</code> <code class="reqn">= n^{-1/5}</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ticker</code></td>
<td>
<p>Logical; determines if a 'ticker' documents the iteration
progress through <code>sigma</code>. Defaults to FALSE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot</code></td>
<td>
<p>Logical or character or numeric and indicates if graphical
output should be produced. Defaults to <code>FALSE</code> (i.e., no
graphical output is produced). If it is a character string or
a numeric value, graphical output will be written to numbered
pdf-files (one for each element of <code>x</code>, in the current
working directory) whose names start with the provided
“value” after converting it into a character string
followed by the index number of the pertaining
<code>x</code>-element. (Parts of the graphical output are
generated by <code>minimize_MSEHat</code>.)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parlist</code></td>
<td>
<p>A list of graphical parameters; affects only the pdf-files
(if any are created at all). Default: <code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Possible further arguments passed to <code>minimize_MSEHat()</code>
(where they are currently ignored).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The computational procedure in this function can be highly iterative because
for each point in <code>x</code> (and hence for each row of matrix <code>Ai</code>) the
MSE estimator is computed as a function of <code class="reqn">\sigma</code> on a (usually fine)
<code class="reqn">\sigma</code>-grid provided through <code>sigma</code>. This happens by repeated
calls to <code>bias_AND_scaledvar()</code>. The minimization in <code class="reqn">\sigma</code>
is then performed by <code>minimize_MSEHat()</code> using both a discrete
grid-search and the numerical optimization routine implemented in base R's
<code>optimize()</code>. Finally, <code>compute_fnhat()</code> yields the actual
value of the density estimator for the adapted <code class="reqn">\sigma</code>, i.e., for the
MSE-estimator-minimizing <code class="reqn">\sigma</code>.
(If necessary the computation over the <code class="reqn">\sigma</code>-grid is repeated after
extending the range of the grid until the estimator functions for both bias
and variance are <em>not constant</em> across the <code class="reqn">\sigma</code>-grid.)
</p>


<h3>Value</h3>

<p>A list of as many lists as elements in <code>x</code>, each with components
<code>x</code>, <code>y</code>, <code>sigma.adap</code>, <code>msehat.min</code>,
<code>discr.min.smaller</code>, and <code>sig.range.adj</code> whose meanings are as
follows:
</p>

<table>
<tr>
<td style="text-align: left;">
   <code>x</code> </td>
<td style="text-align: left;"> the n coordinates of the points where the density is
            estimated. </td>
</tr>
<tr>
<td style="text-align: left;">
   <code>y</code> </td>
<td style="text-align: left;"> the estimate of the density value <code class="reqn">f(x)</code>. </td>
</tr>
<tr>
<td style="text-align: left;">
   <code>sigma.adap</code> </td>
<td style="text-align: left;"> Minimizer of MSE-estimator (from function
                     <code>minimize_MSEHat</code>). </td>
</tr>
<tr>
<td style="text-align: left;">
   <code>msehat.min</code> </td>
<td style="text-align: left;"> Minimum of MSE-estimator (from function
                     <code>minimize_MSEHat</code>). </td>
</tr>
<tr>
<td style="text-align: left;">
   <code>discr.min.smaller</code> </td>
<td style="text-align: left;"> TRUE iff the numerically found minimum was
                            smaller than the discrete one (from function
                            <code>minimize_MSEHat</code>). </td>
</tr>
<tr>
<td style="text-align: left;">
   <code>sig.range.adj</code> </td>
<td style="text-align: left;"> Number of adjustments of sigma-range. </td>
</tr>
<tr>
<td style="text-align: left;">
   </td>
</tr>
</table>
<h3>References</h3>

<p>Srihera &amp; Stute (2011) and Eichner &amp; Stute (2013): see
kader.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
require(stats)

 # Kernel adaptive density estimators for simulated N(0,1)-data
 # computed on an x-grid using the rank transformation and the
 # non-robust method:
set.seed(2017);     n &lt;- 100;     Xdata &lt;- sort(rnorm(n))
x &lt;- seq(-4, 4, by = 0.5);     Sigma &lt;- seq(0.01, 10, length = 51)
h &lt;- n^(-1/5)

x.X_h &lt;- outer(x/h, Xdata/h, "-")
fnx &lt;- rowMeans(dnorm(x.X_h)) / h   # Parzen-Rosenblatt estim. at
                                    # x_j, j = 1, ..., length(x).
 # non-robust method:
theta.X &lt;- mean(Xdata) - Xdata
adaptive_fnhat(x = x, data = Xdata, K = dnorm, h = h, sigma = Sigma,
  Ai = x.X_h, Bj = theta.X, fnx = fnx, ticker = TRUE, plot = TRUE)

 # rank transformation-based method (requires sorted data):
negJ &lt;- -J_admissible(1:n / n)   # rank trafo
adaptive_fnhat(x = x, data = Xdata, K = dnorm, h = h, sigma = Sigma,
  Ai = x.X_h, Bj = negJ, fnx = fnx, ticker = TRUE, plot = TRUE)

## End(Not run)

</code></pre>


</div>