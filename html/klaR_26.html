<div class="container">

<table style="width: 100%;"><tr>
<td>shardsplot</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Plotting Eight Direction Arranged Maps or Self-Organizing Maps</h2>

<h3>Description</h3>

<p>Plotting method for objects of <code>class</code> <code>EDAM</code> or <code>som</code>. 
</p>


<h3>Usage</h3>

<pre><code class="language-R">shardsplot(object, plot.type = c("eight", "four", "points", "n"), 
    expand = 1, stck = TRUE, grd = FALSE, standardize = FALSE, 
    data.or = NA, label = FALSE, plot = TRUE, classes = 0, 
    vertices = TRUE, classcolors = "rainbow", wghts = 0, 
    xlab = "Dimension 1", ylab = "Dimension 2", xaxs = "i", 
    yaxs = "i", plot.data.column = NA,
    log.classes = FALSE, revert.colors = FALSE, ...)

level_shardsplot(object, par.names, rows = 1:NCOL(object$data),
    centers = rep(NA, length(par.names)), class.labels = NA,
    revert.colors = rep(FALSE, length(par.names)), 
    log.classes = rep(FALSE, length(par.names)),
    centeredcolors = colorRamp(c("red", "white", "blue")),
    mfrow = c(2, 2), plot.type = c("eight", "four", "points", "n"),
    expand = 1, stck = TRUE, grd = FALSE, standardize = FALSE,
    label = FALSE, plot = TRUE, vertices = TRUE, classcolors = "topo",
    wghts = 0, xlab = "Dimension 1", ylab = "Dimension 2",
    xaxs = "i", yaxs = "i", ...)

## S3 method for class 'EDAM'
plot(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>an object of class <code>EDAM</code> or <code>som</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>par.names</code></td>
<td>
<p>names used to lable the data columns</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rows</code></td>
<td>
<p>vector with indices of colomns to be plotted</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>centers</code></td>
<td>
<p>vector of type numeric defining the class centers for the data. NA if data does not have a center.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>class.labels</code></td>
<td>
<p>matrix of type text and <code>dimension(3, NROW(object$data))</code> defining the lables to be used for maximum, minimum and central value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>centeredcolors</code></td>
<td>
<p>colors to represent the classes with a central value</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mfrow</code></td>
<td>
<p>parameter defining number of plots on a page. see <code>par</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot.type</code></td>
<td>
<p>a character giving the shape of the shards. 
Available are “<code>eight</code>” and “<code>four</code>” for octagons resp. rectangles, 
and “<code>points</code>” for points. If <code>plot.type</code> is “<code>n</code>”, 
no shards are plotted at all.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>expand</code></td>
<td>
<p>a numeric giving the relative expansion of the axes. 
A value greater than one implies smaller shards. Varying <code>expand</code>
can be sensible for visual reasons.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stck</code></td>
<td>
<p>logical. If <code>TRUE</code> the cells are varied continously corresponding to 
the differences of direct neighbors in the origin space. 
Within this variation the relative order of the cells is always preserved.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grd</code></td>
<td>
<p>logical. If <code>TRUE</code> (which automatically sets <code>stck</code> to <code>TRUE</code>), 
the variation of cells is restricted to their original discrete values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>standardize</code></td>
<td>
<p>logical. If <code>TRUE</code>, then the measurements in <code>object$preimages</code> 
are standardized before calculating Euclidean distances. 
Measurements are standardized for each variable by dividing by the variable's 
standard deviation. Meaningless if <code>object$preimages</code> is a dissimilarity matrix. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data.or</code></td>
<td>
<p>original data and classes where the first k columns are variables and the (k+1)-th column are the classes.
If defined and class of <code>object</code> is <code>som</code>, <code>data.or</code> is used to assign a class to each codebook. There
a codebook receives the class, from which the majority of its assigned objects origins.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>label</code></td>
<td>
<p>logical. If <code>TRUE</code>, the shards are labeled by the rownames of the preimages.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot</code></td>
<td>
<p>logical. If <code>FALSE</code>, all graphical output is suppressed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>classes</code></td>
<td>
<p>a vector giving alternative classes for objects of class <code>EDAM</code>; <code>classes</code> have to be given in 
the original order of the data to which <code>EDAM</code> was applied.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vertices</code></td>
<td>
<p>logical. If <code>TRUE</code> the grid is drawn.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>classcolors</code></td>
<td>
<p>colors to represent the classes, or a character giving the <em>colorscale</em> for the classes. 
Since now available scales are <code>rainbow</code>, <code>topo</code> and <code>gray</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wghts</code></td>
<td>
<p> an optional vector of length k giving relative weights of the variables 
in computing Euclidean distances. Meaningless if <code>object$preimages</code> is a dissimilarity matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xaxs</code></td>
<td>
<p>see <code>par</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>yaxs</code></td>
<td>
<p>see <code>par</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xlab</code></td>
<td>
<p>see <code>par</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ylab</code></td>
<td>
<p>see <code>par</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further plotting parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot.data.column</code></td>
<td>
<p>column index defining from <code>data.or</code> providing the data used to calculate the coloring of the cells.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>log.classes</code></td>
<td>
<p>boolean indicating that the data should be transformed with the logarithmic function before calculating the cell coloring</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>revert.colors</code></td>
<td>
<p>boolean indicating that the colorscale should be reverted.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>level_shardsplot</code> uses multiple <code>shardsplot</code> representations of a SOM in order to depict how 
the data used to calculate the SOM is distribution across the map. 
Two representations are possible for the data, first with a single color ramp from the minimum 
value to the maximum value. The second representation is usefull for data for which a basic 
value exists some where between minimum and maximum for which a special color representation should be used 
(e.g. 0 is indicated with white).
</p>
<p>If <code>plot.type</code> is “<code>four</code>” or “<code>eight</code>”, the shape of each shard depends 
on the relative distances of the actual object 
or codebook to its up to eight neighbours. If <code>plot.type</code> is “<code>eight</code>”, <code>shardsplot</code>
corresponds to the representation method
suggested by Cottrell and de Bodt (1996) for Kohonen Self-Organizing Maps. 
If <code>plot.type</code> is “<code>points</code>”, <code>shardsplot</code> reduces to a usual scatter plot.
</p>


<h3>Value</h3>

<p>The following list is (invisibly) returned:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>Cells.ex</code></td>
<td>
<p>the images of the visualized data</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>S</code></td>
<td>
<p>the criterion of the visualization</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Nils Raabe, <code>level_shardsplot</code> function from Dominik Reusser</p>


<h3>References</h3>

<p>Cottrell, M., and de Bodt, E. (1996).
A Kohonen Map Representation to Avoid Misleading Interpretations.
<em>Proceedings of the European Symposium on Atrificial Neural Networks</em>, D-Facto, pp. 103–110.
</p>


<h3>See Also</h3>

<p><code>EDAM</code>, <code>TopoS</code>, <code>som</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Compute clusters and an Eight Directions Arranged Map for the 
# country data. Plotting the result.
data(countries)
logcount &lt;- log(countries[,2:7])
sdlogcount &lt;- apply(logcount, 2, sd)
logstand &lt;- t((t(logcount) / sdlogcount) * c(1,2,6,5,5,3))
cclasses &lt;- cutree(hclust(dist(logstand)), k = 6)
countryEDAM &lt;- EDAM(logstand, classes = cclasses, sa = FALSE, 
    iter.max = 10, random = FALSE)
plot(countryEDAM, vertices = FALSE, label = TRUE, stck = FALSE)

# Compute and plot a Self-Organizing Map for the iris data
data(iris)
library(som)
irissom &lt;- som(iris[,1:4], xdim = 6, ydim = 14)
shardsplot(irissom, data.or = iris, vertices = FALSE)
opar &lt;- par(xpd = NA)
legend(7.5, 6.1, col = rainbow(3), xjust = 0.5, yjust = 0,
    legend = levels(iris[, 5]), pch = 16, horiz = TRUE)
par(opar)    

level_shardsplot(irissom, par.names = names(iris), 
    class.labels = NA, mfrow = c(2,2))
</code></pre>


</div>