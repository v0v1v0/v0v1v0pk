<div class="container">

<table style="width: 100%;"><tr>
<td>kfe</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Kernel functional estimate</h2>

<h3>Description</h3>

<p>Kernel functional estimate for 1- to 6-dimensional data.</p>


<h3>Usage</h3>

<pre><code class="language-R">kfe(x, G, deriv.order, inc=1, binned, bin.par, bgridsize, deriv.vec=TRUE,
    add.index=TRUE, verbose=FALSE)
Hpi.kfe(x, nstage=2, pilot, pre="sphere", Hstart, binned=FALSE, 
    bgridsize, amise=FALSE, deriv.order=0, verbose=FALSE, optim.fun="optim")
Hpi.diag.kfe(x, nstage=2, pilot, pre="scale", Hstart, binned=FALSE,
    bgridsize, amise=FALSE, deriv.order=0, verbose=FALSE, optim.fun="optim")
hpi.kfe(x, nstage=2, binned=FALSE, bgridsize, amise=FALSE, deriv.order=0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>vector/matrix of data values</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nstage</code></td>
<td>
<p>number of stages in the plug-in bandwidth selector (1 or 2)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pilot</code></td>
<td>
<p>"dscalar" = single pilot bandwidth (default) <br>
"dunconstr" = single unconstrained pilot bandwidth</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pre</code></td>
<td>
<p>"scale" = <code>pre.scale</code>, "sphere" = <code>pre.sphere</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Hstart</code></td>
<td>
<p>initial bandwidth matrix, used in numerical optimisation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>binned</code></td>
<td>
<p>flag for binned estimation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bgridsize</code></td>
<td>
<p>vector of binning grid sizes</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>amise</code></td>
<td>
<p>flag to return the minimal scaled PI value</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>deriv.order</code></td>
<td>
<p>derivative order</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>flag to print out progress information. Default is FALSE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optim.fun</code></td>
<td>
<p>optimiser function: one of <code>nlm</code> or <code>optim</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>G</code></td>
<td>
<p>pilot bandwidth matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inc</code></td>
<td>
<p>0=exclude diagonal, 1=include diagonal terms in kfe
calculation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bin.par</code></td>
<td>
<p>binning parameters - output from <code>binning</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>deriv.vec</code></td>
<td>
<p>flag to compute duplicated partial derivatives in the 
vectorised form. Default is FALSE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>add.index</code></td>
<td>
<p>flag to output derivative indices matrix. Default is true.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>Hpi.kfe</code> is the optimal plug-in bandwidth for <code class="reqn">r</code>-th order kernel functional estimator
based on the unconstrained pilot selectors of Chacon &amp; Duong (2010).
<code>hpi.kfe</code> is the 1-d equivalent, using the formulas from
Wand &amp; Jones (1995, p.70).
</p>
<p><code>kfe</code> does not usually need to be called explicitly by the user.     
</p>


<h3>Value</h3>

<p>Plug-in bandwidth matrix for <code class="reqn">r</code>-th order kernel functional estimator.
</p>


<h3>References</h3>

<p>Chacon, J.E. &amp; Duong, T. (2010) Multivariate plug-in bandwidth
selection with unconstrained pilot matrices. <em>Test</em>, <b>19</b>,
375-398.
</p>
<p>Wand, M.P. &amp; Jones, M.C. (1995) <em>Kernel Smoothing</em>. Chapman &amp;
Hall/CRC, London. 
</p>


<h3>See Also</h3>

<p><code>kde.test</code></p>


</div>